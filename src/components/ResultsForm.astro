---
import LoadingOverlay from "@/components/LoadingOverlay.tsx";
---

<form class="max-w-sm md:max-w-none" id="results-form">
  <div class="grid grid-cols-1 gap-4 md:grid-cols-2 max-w-none mb-5">
    <div>
      <label for="race-type-results" class="block mb-2 text-sm font-regular">
        Seleccione el tipo de carrera
      </label>
      <select
        id="race-type-results"
        class="bg-secondary border border-gray-300 text-sm rounded-lg block w-full p-2.5"
      >
        <option value="">Seleccione el tipo de carrera</option>
        <option value="gp">Gran Premio</option>
        <option value="sprint">Sprint</option>
      </select>
    </div>
    <div>
      <label for="race-result" class="block mb-2 text-sm font-regular">
        Seleccione la carrera *
      </label>
      <select
        id="race-results"
        class="bg-secondary border border-gray-300 text-sm rounded-lg block w-full p-2.5"
        required
      >
        <option value="">Seleccione la carrera</option>
      </select>
    </div>
  </div>

  <hr class="border border-footer mb-5" />

  <div class="mb-5" id="podium-container"></div>

  <div class="flex flex-col gap-4">
    <button
      type="submit"
      id="submit-button-results"
      class="text-primary bg-accent border border-gray-300 hover:bg-secondary font-regular rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center cursor-auto"
      disabled
    >
      Guardar Resultados
    </button>
    <button
      type="button"
      id="delete-button-results"
      class="text-primary bg-red-500 border border-gray-300 hover:bg-red-600 font-regular rounded-lg text-sm w-full sm:w-auto px-5 py-2.5 text-center cursor-pointer hidden"
    >
      Eliminar Resultados
    </button>
  </div>
</form>

<LoadingOverlay client:load />

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const raceTypeSelect = document.getElementById(
      "race-type-results"
    ) as HTMLSelectElement;
    const raceSelect = document.getElementById(
      "race-results"
    ) as HTMLSelectElement;
    const podiumContainer = document.getElementById(
      "podium-container"
    ) as HTMLDivElement;
    const form = document.getElementById("results-form") as HTMLFormElement;
    const submitButton = document.getElementById(
      "submit-button-results"
    ) as HTMLButtonElement;
    const deleteButton = document.getElementById(
      "delete-button-results"
    ) as HTMLButtonElement;

    type FilterableDriverField = {
      element: HTMLDivElement;
      setDrivers: (driversList: any[]) => void;
      setValue: (value: string | null) => void;
      getValue: () => string | null;
      destroy: () => void;
    };

    let allRaces: any[] = [];
    let drivers: any[] = [];
    let currentResult: any = null;
    let isUpdateMode = false;

    const resultPickers: FilterableDriverField[] = [];

    let formData: {
      [key: string]: number | null;
      position_result_first: number | null;
      position_result_second: number | null;
      position_result_third: number | null;
    } = {
      position_result_first: null,
      position_result_second: null,
      position_result_third: null,
    };

    function createFilterableDriverField({
      labelText,
      name,
      inputId,
      onChange,
    }: {
      labelText: string;
      name: string;
      inputId: string;
      onChange: (value: string | null) => void;
    }): FilterableDriverField {
      const wrapper = document.createElement("div");
      wrapper.classList.add("flex", "flex-col", "gap-2");

      const label = document.createElement("label");
      label.innerText = labelText;
      label.setAttribute("for", inputId);
      label.className = "block text-sm font-regular";

      const controlWrapper = document.createElement("div");
      controlWrapper.className = "relative";

      const input = document.createElement("input");
      input.type = "text";
      input.id = inputId;
      input.placeholder = "Buscar piloto...";
      input.className =
        "bg-secondary border border-gray-300 text-sm rounded-lg block w-full p-2.5 pr-10";
      input.autocomplete = "off";

      const toggleButton = document.createElement("button");
      toggleButton.type = "button";
      toggleButton.innerHTML = "&#9662;";
      toggleButton.className =
        "absolute inset-y-0 right-2 flex items-center text-gray-400 hover:text-primary focus:text-primary";
      toggleButton.setAttribute("aria-label", "Mostrar opciones de piloto");

      const dropdown = document.createElement("ul");
      dropdown.className =
        "absolute z-10 mt-1 w-full bg-secondary border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto hidden";

      const hiddenInput = document.createElement("input");
      hiddenInput.type = "hidden";
      hiddenInput.name = name;

      controlWrapper.appendChild(input);
      controlWrapper.appendChild(toggleButton);
      controlWrapper.appendChild(dropdown);
      controlWrapper.appendChild(hiddenInput);

      wrapper.appendChild(label);
      wrapper.appendChild(controlWrapper);

      let availableDrivers: any[] = [];
      let filteredDrivers: any[] = [];
      let highlightedIndex = -1;
      let searchTerm = "";
      let isListOpen = false;

      function highlightOption(index: number) {
        const options = dropdown.querySelectorAll("li[data-index]");
        options.forEach((option) => {
          option.classList.remove("bg-accent", "text-primary");
        });

        if (index >= 0 && index < options.length) {
          const option = options[index] as HTMLLIElement;
          option.classList.add("bg-accent", "text-primary");
          highlightedIndex = index;
        } else {
          highlightedIndex = -1;
        }
      }

      function renderList() {
        const normalized = searchTerm.trim().toLowerCase();
        filteredDrivers = normalized
          ? availableDrivers.filter((driver: any) =>
              driver.name.toLowerCase().includes(normalized)
            )
          : [...availableDrivers];

        dropdown.innerHTML = "";

        if (!filteredDrivers.length) {
          const emptyState = document.createElement("li");
          emptyState.textContent = "Sin coincidencias";
          emptyState.className = "px-3 py-2 text-sm text-gray-400";
          dropdown.appendChild(emptyState);
          highlightOption(-1);
          return;
        }

        filteredDrivers.forEach((driver: any, index: number) => {
          const option = document.createElement("li");
          option.textContent = driver.name;
          option.setAttribute("data-index", index.toString());
          option.className =
            "px-3 py-2 cursor-pointer hover:bg-accent hover:text-primary text-sm";
          option.addEventListener("mousedown", (event) => {
            event.preventDefault();
            selectDriver(driver);
          });
          dropdown.appendChild(option);
        });

        if (hiddenInput.value && !searchTerm) {
          const selectedIndex = filteredDrivers.findIndex(
            (driver: any) => driver.id.toString() === hiddenInput.value
          );
          highlightOption(selectedIndex);
        } else {
          highlightOption(filteredDrivers.length ? 0 : -1);
        }
      }

      function showList() {
        if (!isListOpen) {
          dropdown.classList.remove("hidden");
          isListOpen = true;
        }
      }

      function hideList() {
        if (isListOpen) {
          dropdown.classList.add("hidden");
          isListOpen = false;
          highlightOption(-1);
        }
      }

      function syncSelection() {
        if (!hiddenInput.value) {
          if (!searchTerm) {
            input.value = "";
          }
          return;
        }

        const selectedDriver = availableDrivers.find(
          (driver: any) => driver.id.toString() === hiddenInput.value
        );

        if (selectedDriver) {
          input.value = selectedDriver.name;
        }
      }

      function selectDriver(driver: any) {
        hiddenInput.value = driver.id.toString();
        input.value = driver.name;
        searchTerm = "";
        hideList();
        onChange(hiddenInput.value);
      }

      input.addEventListener("focus", () => {
        searchTerm = "";
        renderList();
        showList();
        setTimeout(() => input.select(), 0);
      });

      input.addEventListener("click", () => {
        renderList();
        showList();
      });

      input.addEventListener("input", () => {
        searchTerm = input.value;
        hiddenInput.value = "";
        onChange(null);
        renderList();
        showList();
        if (filteredDrivers.length) {
          highlightOption(0);
        }
      });

      input.addEventListener("keydown", (event) => {
        const key = event.key;
        if (key === "ArrowDown") {
          event.preventDefault();
          if (!isListOpen) {
            renderList();
            showList();
          }
          if (!filteredDrivers.length) return;
          const nextIndex = highlightedIndex + 1;
          highlightOption(
            nextIndex >= filteredDrivers.length ? 0 : nextIndex
          );
        } else if (key === "ArrowUp") {
          event.preventDefault();
          if (!isListOpen) {
            renderList();
            showList();
          }
          if (!filteredDrivers.length) return;
          const prevIndex =
            highlightedIndex <= 0
              ? filteredDrivers.length - 1
              : highlightedIndex - 1;
          highlightOption(prevIndex);
        } else if (key === "Enter") {
          event.preventDefault();
          if (!isListOpen) {
            renderList();
            showList();
            return;
          }
          if (highlightedIndex >= 0 && highlightedIndex < filteredDrivers.length) {
            selectDriver(filteredDrivers[highlightedIndex]);
          } else if (filteredDrivers.length === 1) {
            selectDriver(filteredDrivers[0]);
          }
        } else if (key === "Escape") {
          hideList();
        }
      });

      toggleButton.addEventListener("click", (event) => {
        event.preventDefault();
        if (isListOpen) {
          hideList();
        } else {
          input.focus();
          searchTerm = "";
          renderList();
          showList();
        }
      });

      const handleDocumentClick = (event: MouseEvent) => {
        if (!wrapper.contains(event.target as Node)) {
          hideList();
          if (!hiddenInput.value && !searchTerm) {
            input.value = "";
          }
        }
      };

      document.addEventListener("click", handleDocumentClick);

      const field: FilterableDriverField = {
        element: wrapper,
        setDrivers(driversList: any[]) {
          availableDrivers = Array.isArray(driversList) ? driversList : [];
          if (isListOpen) {
            renderList();
          }
          syncSelection();
        },
        setValue(value: string | null) {
          hiddenInput.value = value ?? "";
          searchTerm = "";
          syncSelection();
          if (!hiddenInput.value) {
            onChange(null);
          } else {
            onChange(hiddenInput.value);
          }
        },
        getValue() {
          return hiddenInput.value || null;
        },
        destroy() {
          document.removeEventListener("click", handleDocumentClick);
          hideList();
        },
      };

      return field;
    }

    function validateForm() {
      if (!raceSelect.value) return false;
      const {
        position_result_first,
        position_result_second,
        position_result_third,
      } = formData;
      if (
        position_result_first === null ||
        position_result_second === null ||
        position_result_third === null
      )
        return false;
      if (
        position_result_first === position_result_second ||
        position_result_first === position_result_third ||
        position_result_second === position_result_third
      )
        return false;
      return true;
    }

    function toggleSubmitButton() {
      if (validateForm()) {
        submitButton.disabled = false;
        submitButton.classList.remove("opacity-50", "cursor-not-allowed");
        submitButton.classList.add("cursor-pointer");
      } else {
        submitButton.disabled = true;
        submitButton.classList.add("opacity-50", "cursor-not-allowed");
        submitButton.classList.remove("cursor-pointer");
      }
    }

    function loadRaces() {
      fetch("/api/race-weekends")
        .then((res) => res.json())
        .then((data) => {
          if (data.raceWeekends && Array.isArray(data.raceWeekends)) {
            allRaces = data.raceWeekends;
            filterRaces();
          }
        })
        .catch((err) => console.error("Error al cargar las carreras:", err));
    }

    function filterRaces() {
      raceSelect.innerHTML = "";
      const defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.text = "Seleccione la carrera";
      raceSelect.appendChild(defaultOption);

      const selectedRaceType = raceTypeSelect.value;
      const filteredRaces = selectedRaceType
        ? allRaces.filter((race: any) => race.race_type === selectedRaceType)
        : allRaces;

      filteredRaces.forEach((race: any) => {
        const option = document.createElement("option");
        option.value = race.id.toString();
        option.text = `Ronda ${race.round_number}: ${race.race_name} (${race.race_type})`;
        raceSelect.appendChild(option);
      });
    }

    function loadDrivers() {
      fetch("/api/drivers")
        .then((res) => res.json())
        .then((data) => {
          if (data.drivers && Array.isArray(data.drivers)) {
            drivers = data.drivers;
            resultPickers.forEach((picker) => picker.setDrivers(drivers));
          }
        })
        .catch((err) => console.error("Error al cargar los pilotos:", err));
    }

    function loadResult(raceId: string) {
      const token = sessionStorage.getItem("token") || "";
      fetch(`/api/results/${raceId}`, {
        headers: { Authorization: `Bearer ${token}` },
      })
        .then((res) => res.json())
        .then((data) => {
          if (!data.error && data.result) {
            currentResult = data.result;
            isUpdateMode = true;
            submitButton.textContent = "Actualizar Resultados";
            deleteButton.classList.remove("hidden");
          } else {
            currentResult = null;
            isUpdateMode = false;
            submitButton.textContent = "Guardar Resultados";
            deleteButton.classList.add("hidden");
          }
          populateResultSelects();
        })
        .catch((err) => {
          console.error("Error al cargar los datos de resultados:", err);
          currentResult = null;
          isUpdateMode = false;
          submitButton.textContent = "Guardar Resultados";
          populateResultSelects();
        });
    }

    function populateResultSelects() {
      resultPickers.forEach((picker) => picker.destroy());
      podiumContainer.innerHTML = "";
      resultPickers.length = 0;

      formData = {
        position_result_first: null,
        position_result_second: null,
        position_result_third: null,
      };

      const positions = [
        { position: 1, key: "position_result_first" },
        { position: 2, key: "position_result_second" },
        { position: 3, key: "position_result_third" },
      ];

      positions.forEach(({ position, key }) => {
        const prefill = currentResult
          ? position === 1
            ? currentResult.position_first
            : position === 2
            ? currentResult.position_second
            : currentResult.position_third
          : null;

        const picker = createFilterableDriverField({
          labelText: `Posición ${position}`,
          name: key,
          inputId: `result-${position}`,
          onChange: (value) => {
            formData[key] = value ? parseInt(value, 10) : null;
            toggleSubmitButton();
          },
        });

        picker.element.classList.add("mb-2");

        if (prefill !== null && prefill !== undefined) {
          picker.setValue(prefill.toString());
        } else {
          picker.setValue(null);
        }

        picker.setDrivers(drivers);

        resultPickers.push(picker);
        podiumContainer.appendChild(picker.element);
      });

      toggleSubmitButton();
    }

    raceTypeSelect.addEventListener("change", () => {
      filterRaces();
    });

    raceSelect.addEventListener("change", () => {
      const raceId = raceSelect.value;
      if (raceId) {
        loadResult(raceId);
      } else {
        resultPickers.forEach((picker) => picker.destroy());
        podiumContainer.innerHTML = "";
        resultPickers.length = 0;
        submitButton.textContent = "Guardar Resultados";
        deleteButton.classList.add("hidden");
        formData = {
          position_result_first: null,
          position_result_second: null,
          position_result_third: null,
        };
        toggleSubmitButton();
      }
    });

    form.addEventListener("submit", (e) => {
      window.dispatchEvent(new CustomEvent("toggleLoading", { detail: true }));

      e.preventDefault();
      const positions = resultPickers.map((picker) => {
        const value = picker.getValue();
        return value ? parseInt(value, 10) : null;
      });

      const raceId = raceSelect.value;
      if (!raceId) {
        window.toast({
          title: "Error",
          message: "Debe seleccionar una carrera",
          type: "error",
          dismissible: true,
          icon: true,
        });
        return;
      }

      if (positions.some((position) => position === null)) {
        window.toast({
          title: "Error",
          message: "Debe seleccionar los tres pilotos",
          type: "error",
          dismissible: true,
          icon: true,
        });
        return;
      }

      const payload = {
        race_weekend_id: parseInt(raceId, 10),
        position_first: positions[0],
        position_second: positions[1],
        position_third: positions[2],
      };

      const token = sessionStorage.getItem("token") ?? "";
      const method = isUpdateMode ? "PATCH" : "POST";
      const url = "/api/results/" + (isUpdateMode ? currentResult.id : "");

      fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(payload),
      })
        .then((res) => res.json())
        .then((data) => {
          if (data) {
            window.dispatchEvent(
              new CustomEvent("toggleLoading", { detail: false })
            );
          }

          if (data.error) {
            window.toast({
              title: "Error",
              message: data.error,
              type: "error",
              dismissible: true,
              icon: true,
            });
          } else {
            window.toast({
              title: "Éxito",
              message: isUpdateMode
                ? "Resultados actualizados correctamente"
                : "Resultados guardados correctamente",
              type: "success",
              dismissible: true,
              icon: true,
            });

            fetch(`/api/predictions/calculate/${raceId}`, {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(payload),
            })
              .then((res) => res.json())
              .then((data) => {
                if (data.error) {
                  window.toast({
                    title: "Error",
                    message: data.error,
                    type: "error",
                    dismissible: true,
                    icon: true,
                  });
                } else {
                  window.toast({
                    title: "Éxito",
                    message: "Puntos calculados correctamente",
                    type: "success",
                    dismissible: true,
                    icon: true,
                  });

                  // setInterval(() => {
                  //   window.location.reload();
                  // }, 1500);
                }
              })
              .catch((err) => {
                console.error("Error al calcular los puntos:", err);
                window.toast({
                  title: "Error",
                  message: "Server error",
                  type: "error",
                  dismissible: true,
                  icon: true,
                });
              });
          }
        })
        .catch((err) => {
          console.error("Error al registrar los resultados:", err);
          window.toast({
            title: "Error",
            message: "Server error",
            type: "error",
            dismissible: true,
            icon: true,
          });
        });
    });

    deleteButton.addEventListener("click", () => {
      if (!currentResult) return;
      if (!confirm("¿Eliminar resultados?")) return;
      window.dispatchEvent(new CustomEvent("toggleLoading", { detail: true }));
      const token = sessionStorage.getItem("token") || "";
      fetch(`/api/results/${currentResult.id}`, {
        method: "DELETE",
        headers: { Authorization: `Bearer ${token}` },
      })
        .then((res) => res.json())
        .then((data) => {
          window.dispatchEvent(new CustomEvent("toggleLoading", { detail: false }));
          if (data.error) {
            window.toast({
              title: "Error",
              message: data.error,
              type: "error",
              dismissible: true,
              icon: true,
            });
          } else {
            window.toast({
              title: "Éxito",
              message: "Resultados eliminados correctamente",
              type: "success",
              dismissible: true,
              icon: true,
            });
            setTimeout(() => {
              window.location.reload();
            }, 1500);
          }
        })
        .catch((err) => {
          console.error("Error al eliminar los resultados:", err);
          window.toast({
            title: "Error",
            message: "Server error",
            type: "error",
            dismissible: true,
            icon: true,
          });
        });
    });

    loadRaces();
    loadDrivers();
    toggleSubmitButton();
  });
</script>

